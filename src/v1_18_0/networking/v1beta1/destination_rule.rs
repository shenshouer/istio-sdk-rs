// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -Af -
// kopium version: 0.15.0
// changed by Shouer.shen at 2023.07.21

use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, time::Duration};

use crate::types::PortSelector;

/// Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
#[kube(
    group = "networking.istio.io",
    version = "v1beta1",
    kind = "DestinationRule",
    plural = "destinationrules"
)]
#[kube(namespaced)]
pub struct DestinationRuleSpec {
    /// The name of a service from the service registry.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub host: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "trafficPolicy"
    )]
    pub traffic_policy: Option<TrafficPolicy>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subsets: Option<Vec<Subsets>>,
    /// A list of namespaces to which this destination rule is exported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exportTo")]
    pub export_to: Option<Vec<String>>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "workloadSelector"
    )]
    pub workload_selector: Option<WorkloadSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct Subsets {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
    /// Name of the subset.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Traffic policies that apply to this subset.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "trafficPolicy"
    )]
    pub traffic_policy: Option<TrafficPolicy>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct TrafficPolicy {
    /// Settings controlling the load balancer algorithms.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loadBalancer"
    )]
    pub load_balancer: Option<LoadBalancerSettings>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionPool"
    )]
    pub connection_pool: Option<ConnectionPoolSettings>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outlierDetection"
    )]
    pub outlier_detection: Option<OutlierDetection>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClientTLSSettings>,
    /// Traffic policies specific to individual ports.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "portLevelSettings"
    )]
    pub port_level_settings: Option<Vec<PortTrafficPolicy>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tunnel: Option<TunnelSettings>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ConnectionPoolSettings {
    /// HTTP connection pool settings.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<HTTPSettings>,
    /// Settings common to both HTTP and TCP upstream connections.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tcp: Option<TCPSettings>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct HTTPSettings {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "http1MaxPendingRequests"
    )]
    pub http1_max_pending_requests: Option<i32>,
    /// Maximum number of active requests to a destination.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "http2MaxRequests"
    )]
    pub http2_max_requests: Option<i32>,
    /// Maximum number of requests per connection to a backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRequestsPerConnection"
    )]
    pub max_requests_per_connection: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxRetries"
    )]
    pub max_retries: Option<i32>,
    /// The idle timeout for upstream connection pool connections.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "idleTimeout"
    )]
    pub idle_timeout: Option<String>,
    /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "h2UpgradePolicy"
    )]
    pub h2_upgrade_policy: Option<H2UpgradePolicy>,
    /// If set to true, client protocol will be preserved while initiating connection to backend.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useClientProtocol"
    )]
    pub use_client_protocol: Option<bool>,
}

/// HTTP connection pool settings.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum H2UpgradePolicy {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "DO_NOT_UPGRADE")]
    DoNotUpgrade,
    #[serde(rename = "UPGRADE")]
    Upgrade,
}

/// Settings common to both HTTP and TCP upstream connections.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TCPSettings {
    /// Maximum number of HTTP1 /TCP connections to a destination host.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnections"
    )]
    pub max_connections: Option<i32>,

    /// TCP connection timeout.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectTimeout"
    )]
    pub connect_timeout: Option<Duration>,
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "tcpKeepalive"
    )]
    pub tcp_keepalive: Option<TcpKeepalive>,
    /// The maximum duration of a connection.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxConnectionDuration"
    )]
    pub max_connection_duration: Option<Duration>,
}

/// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TcpKeepalive {
    /// The time duration between keep-alive probes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probes: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LoadBalancerSettings {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub simple: Option<SimpleLB>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consistentHash"
    )]
    pub consistent_hash: Option<ConsistentHashLB>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "localityLbSetting"
    )]
    pub locality_lb_setting: Option<LocalityLoadBalancerSetting>,

    /// Represents the warmup duration of Service.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "warmupDurationSecs"
    )]
    pub warmup_duration_secs: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ConsistentHashLB {
    /// Hash based on a specific HTTP header.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpHeaderName"
    )]
    pub http_header_name: Option<String>,
    /// Hash based on HTTP cookie.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpCookie"
    )]
    pub http_cookie: Option<HttpCookie>,
    /// Hash based on the source IP address.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "useSourceIp"
    )]
    pub use_source_ip: Option<bool>,
    /// Hash based on a specific HTTP query parameter.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "httpQueryParameterName"
    )]
    pub http_query_parameter_name: Option<String>,
    /// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ringHash")]
    pub ring_hash: Option<RingHash>,
    /// The Maglev load balancer implements consistent hashing to backend hosts.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maglev: Option<Maglev>,
    /// Deprecated.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minimumRingSize"
    )]
    pub minimum_ring_size: Option<u64>,
}

/// Hash based on HTTP cookie.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct HttpCookie {
    /// Name of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to set for the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Lifetime of the cookie.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

/// The Maglev load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct Maglev {
    /// The table size for Maglev hashing.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableSize")]
    pub table_size: Option<u64>,
}

/// The ring/modulo hash load balancer implements consistent hashing to backend hosts.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct RingHash {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minimumRingSize"
    )]
    pub minimum_ring_size: Option<u64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct LocalityLoadBalancerSetting {
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribute: Option<Vec<Distribute>>,
    /// Optional: only one of distribute, failover or failoverPriority can be set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failover: Option<Vec<Failover>>,
    /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "failoverPriority"
    )]
    pub failover_priority: Option<Vec<String>>,
    /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct Distribute {
    /// Originating locality, '/' separated, e.g.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    /// Map of upstream localities to traffic distribution weights.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<BTreeMap<String, i64>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct Failover {
    /// Originating region.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
}

/// Settings controlling the load balancer algorithms.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum SimpleLB {
    #[serde(rename = "UNSPECIFIED")]
    Unspecified,
    #[serde(rename = "LEAST_CONN")]
    LeastConn,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "PASSTHROUGH")]
    Passthrough,
    #[serde(rename = "ROUND_ROBIN")]
    RoundRobin,
    #[serde(rename = "LEAST_REQUEST")]
    LeastRequest,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct OutlierDetection {
    /// Determines whether to distinguish local origin failures from external errors.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "splitExternalLocalOriginErrors"
    )]
    pub split_external_local_origin_errors: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consecutiveLocalOriginFailures"
    )]
    pub consecutive_local_origin_failures: Option<u32>,
    /// Number of gateway errors before a host is ejected from the connection pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consecutiveGatewayErrors"
    )]
    pub consecutive_gateway_errors: Option<u32>,
    /// Number of 5xx errors before a host is ejected from the connection pool.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consecutive5xxErrors"
    )]
    pub consecutive5xx_errors: Option<u32>,
    /// Time interval between ejection sweep analysis.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<Duration>,
    /// Minimum ejection duration.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "baseEjectionTime"
    )]
    pub base_ejection_time: Option<Duration>,

    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxEjectionPercent"
    )]
    pub max_ejection_percent: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "minHealthPercent"
    )]
    pub min_health_percent: Option<i32>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "consecutiveErrors"
    )]
    pub consecutive_errors: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct PortTrafficPolicy {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<PortSelector>,
    /// Settings controlling the load balancer algorithms.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "loadBalancer"
    )]
    pub load_balancer: Option<LoadBalancerSettings>,

    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionPool"
    )]
    pub connection_pool: Option<ConnectionPoolSettings>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "outlierDetection"
    )]
    pub outlier_detection: Option<OutlierDetection>,
    /// TLS related settings for connections to the upstream service.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<ClientTLSSettings>,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum TlsMode {
    #[serde(rename = "DISABLE")]
    Disable,
    #[serde(rename = "SIMPLE")]
    Simple,
    #[serde(rename = "MUTUAL")]
    Mutual,
    #[serde(rename = "ISTIO_MUTUAL")]
    IstioMutual,
}

/// TLS related settings for connections to the upstream service.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ClientTLSSettings {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<TlsMode>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "clientCertificate"
    )]
    pub client_certificate: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "caCertificates"
    )]
    pub ca_certificates: Option<String>,

    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "credentialName"
    )]
    pub credential_name: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "subjectAltNames"
    )]
    pub subject_alt_names: Option<Vec<String>>,
    /// SNI string to present to the server during TLS handshake.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sni: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "insecureSkipVerify"
    )]
    pub insecure_skip_verify: Option<bool>,
    /// REQUIRED if mode is `MUTUAL`.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "privateKey"
    )]
    pub private_key: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct TunnelSettings {
    /// Specifies which protocol to use for tunneling the downstream connection.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol: Option<String>,
    /// Specifies a host to which the downstream connection is tunneled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetHost"
    )]
    pub target_host: Option<String>,
    /// Specifies a port to which the downstream connection is tunneled.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "targetPort"
    )]
    pub target_port: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct WorkloadSelector {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "matchLabels"
    )]
    pub match_labels: Option<BTreeMap<String, String>>,
}
